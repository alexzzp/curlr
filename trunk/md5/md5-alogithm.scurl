
{curl-file-attributes character-encoding = "utf8"}

|| from Wikipedia
{define-class public md5-encrypt
  let public constant r:IntVec =
      {IntVec
        7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
        5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
        4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
        6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21
      }

  {method public {encrypt s:ByteVec, len:int}:String
    let k:IntVec = {IntVec.from-size 64, 0}
    || Use binary integer part of the sines of integers as constants:
    {for i = 0 to 63 do
        set k[i] = {floor{abs{sin(i + 1)} × 2^32}}
    }
    || Initialize variables:
    let  h0:int = 0x67452301
    let  h1:int = 0xEFCDAB89
    let  h2:int = 0x98BADCFE
    let  h3:int = 0x10325476

    || Pre-processing -  
    || append "1" bit to message
append "0" bits until message length in bits ≡ 448 (mod 512)
append bit length of message as 64-bit little-endian integer to message

//Process the message in successive 512-bit chunks:
for each 512-bit chunk of message
    break chunk into sixteen 32-bit little-endian words w(i), 0 ≤ i ≤ 15

    ||Initialize hash value for this chunk:
    let  a:int = h0
    let  b:int = h1
    let  c:int = h2
    let  d:int = h3

    || Main loop:
    for i from 0 to 63
        if 0 ≤ i ≤ 15 then
            f := (b and c) or ((not b) and d)
            g := i
        else if 16 ≤ i ≤ 31
            f := (d and b) or ((not d) and c)
            g := (5×i + 1) mod 16
        else if 32 ≤ i ≤ 47
            f := b xor c xor d
            g := (3×i + 5) mod 16
        else if 48 ≤ i ≤ 63
            f := c xor (b or (not d))
            g := (7×i) mod 16
 
        temp := d
        d := c
        c := b
        b := ((a + f + k(i) + w(g)) leftrotate r(i)) + b
        a := temp

    //Add this chunk's hash to result so far:
    h0 := h0 + a
    h1 := h1 + b 
    h2 := h2 + c
    h3 := h3 + d

let int digest := h0 append h1 append h2 append h3 //(expressed as little-endian)
