|| t-shavs.curl
|| maintained by: sadman
||
|| Simple test utility for COM.CURLR.CRYPTO implementations of SHA-1, SHA-224, SHA-256

||
|| Distributed under the New BSD License:
|#
  Copyright (c) 2006, Steve Adams
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification, are permitted 
  provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this list of conditions 
      and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
      and the following disclaimer in the documentation and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors may be used to endorse or promote products 
      derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED 
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY 
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#|
{curl 4.0 applet}
{curl-file-attributes character-encoding = "utf8"}
{applet
    {compiler-directives careful? = true}
}
{import * from COM.CURLR.CRYPTO,
    location = "../load.scurl"
}

{import * from CURL.UTIL.BASE64}

|| read a SHAVs test file construct message digests and compare them
|| header has # to show comments



{define-class public HMAC-TestVector
  
  field public constant sha-test-files:{HashTable-of String, Url} =
      {new {HashTable-of String, Url},
        "HMAC-SHA-512", {url "hmactestvectors/HMAC-SHA512.txt"},
        "HMAC-SHA-384", {url "hmactestvectors/HMAC-SHA384.txt"},
        "HMAC-SHA-256", {url "hmactestvectors/HMAC-SHA256.txt"},
        "HMAC-SHA-224", {url "hmactestvectors/HMAC-SHA224.txt"},
        "HMAC-SHA-1", {url "hmactestvectors/HMAC-SHA1.txt"}
      }

  field public constant test-cases:StringArray = {StringArray}
  
  field public vectors:StringStringTable =
      {StringStringTable}
  field public header:StringArray = {StringArray}
  field public seed:String = ""
  field public msg:StringArray = {StringArray}
  field public mac:StringArray = {StringArray}
  field public key:StringArray = {StringArray}
  field public key-len:{Array-of int} = {{Array-of int}}
  field public trunc-len:{Array-of int} = {{Array-of int}}
  field public count:{Array-of int} = {{Array-of int}}
  field public hmac-sha-512:HMAC-SHA-512
  field public hmac-sha-384:HMAC-SHA-384
  field public hmac-sha-256:HMAC-SHA-256
  field public hmac-sha-224:HMAC-SHA-224
  field public hmac-sha-1:HMAC-SHA-1
  
  field public pass-count:int
  field public test-count:int
  field public constant results:VBox = {VBox}
  field public constant test-count-td:TextDisplay = {TextDisplay width = 2cm}
  field public constant pass-count-td:TextDisplay = {TextDisplay width = 2cm}
  field public constant test-selector:DropdownList
  field public constant run-test-cb:CommandButton
  field public show-fail-only?:bool = true
  field public current-digester:int = 1
  field public current-test-case:String = ""
  {constructor public {default}
    || get ordered list of test cases
    {for key name in self.sha-test-files do
        {self.test-cases.append name}
    }
    {self.test-cases.sort}

    set  self.hmac-sha-512 = {HMAC-SHA-512}
    set  self.hmac-sha-384 = {HMAC-SHA-384}
    set  self.hmac-sha-256 = {HMAC-SHA-256}
    set  self.hmac-sha-224 = {HMAC-SHA-224}
    set  self.hmac-sha-1 = {HMAC-SHA-1}

    
    || create the controls
    set self.test-selector =
        {DropdownList
            prompt = "select test case",
            "run all tests", {splice self.test-cases},
            {on ValueChanged at ddl:DropdownList do
                set self.current-test-case = ddl.value asa String
            }
        }
    
    set self.run-test-cb =
        {CommandButton label = "run test",
            {on Action do
                {if self.test-selector.value asa String == "run all tests" then
                    {self.run-all-test-cases}
                 else
                    {self.reset-for-test-case}
                    {self.run-test-case self.current-test-case}
                }
            }
        }
  }
  
  || parse the contents of a SHAVS files
  {method public {parse-file file:Url}:void
    let count:int = 0
    {with-open-streams
        shs-file = {read-open file} do
        {while not shs-file.end-of-stream? do
            {if-non-null b =  {shs-file.read-line} then
                
                {b.trim}
                
                {if b.size == 0 then {continue}}
                
                || equals?
                {if b[0] == '\[' or
                    b[0] == '#' then 
                    {self.header.append {b.to-String}}
                    {continue}
                }
                {if {b.find-string "="} < 0 then {continue}}
                
                let (s1:String, s2:String) = {self.parse-assignment b}

                {if {s1.to-lower-clone} == "count" then
                    {self.count.append {s2.to-int}}
                }
                {if {s1.to-lower-clone} == "tlen" then
                    {self.trunc-len.append {s2.to-int}}
                }
                {if {s1.to-lower-clone} == "klen" then
                    {self.key-len.append {s2.to-int}}
                }
                {if {s1.to-lower-clone} == "msg" then
                    {self.msg.append s2}
                }
                {if {s1.to-lower-clone} == "key" then
                    {self.key.append s2}
                }
                {if {s1.to-lower-clone} == "mac" then
                    {self.mac.append s2}
                }
                
                {inc count}
                
            }
        }        
    }
  }
  
  {method {parse-assignment s:StringBuf}:(String, String)
    let sa:StringArray =
        {s.split split-chars = {CharClass  "="}}
    {return
        {sa[0].trim-clone},
        {sa[1].trim-clone}
    }
  }
  
  {method public {run-tests}:void
    set self.test-count = self.msg.size
    set self.test-count-td.value = {String self.test-count}
    set self.pass-count = 0
    set self.pass-count-td.value = {String self.pass-count}
    {for i = 0 below self.msg.size do
        {self.run-test i}
    }    
  }

  {method public {run-test index:int}:void
    
    let expected:String = self.mac[index]
    
    let result:String =
        {switch self.current-digester
         case 512 do
            {ByteVec-to-hex-string
                {self.hmac-sha-512.digest-from-ByteVec
                    {ByteVec-from-hex-string self.key[index]},
                    {ByteVec-from-hex-string self.msg[index]},
                    truncate = self.trunc-len[index]
                }
            }
         case 384 do
            {ByteVec-to-hex-string
                {self.hmac-sha-384.digest-from-ByteVec
                    {ByteVec-from-hex-string self.key[index]},
                    {ByteVec-from-hex-string self.msg[index]},
                    truncate = self.trunc-len[index]
                }
            }
         case 256 do
            {ByteVec-to-hex-string
                {self.hmac-sha-256.digest-from-ByteVec
                    {ByteVec-from-hex-string self.key[index]},
                    {ByteVec-from-hex-string self.msg[index]},
                    truncate = self.trunc-len[index]
                }
            }
         case 224 do
            {ByteVec-to-hex-string
                {self.hmac-sha-224.digest-from-ByteVec
                    {ByteVec-from-hex-string self.key[index]},
                    {ByteVec-from-hex-string self.msg[index]},
                    truncate = self.trunc-len[index]
                }
            }
         else
            {ByteVec-to-hex-string
                {self.hmac-sha-1.digest-from-ByteVec
                    {ByteVec-from-hex-string self.key[index]},
                    {ByteVec-from-hex-string self.msg[index]},
                    truncate = self.trunc-len[index]
                }
            }
        }
    
    set result = {result.to-lower-clone}
    let pass?:bool = (result == expected)
    {if pass? then
        {inc self.pass-count}
        set self.pass-count-td.value = {String self.pass-count}
    }
    {if not self.show-fail-only? or not pass? then
        {self.results.add
            {VBox
                {format "string: %w", self.msg[index]},
                {format "expected: %w",expected},
                {format "result: %w", result},
                {if pass? then {text color = "green", PASS}
                 else {bold color = "red", FAILED}
                },
                {hrule}
            }
        }
    }
    {dispatch-events false}
  }
  
  {method public {reset-for-test-case}:void
    set self.test-count = 0
    set self.pass-count = 0
    {self.header.clear}
    {self.msg.clear}
    {self.key-len.clear}
    {self.trunc-len.clear}
    {self.mac.clear}
    {self.key.clear}
    {self.pass-count-td.unset-value}
    {self.test-count-td.unset-value}
  }
  
  {method public {reset-all}:void
    {self.reset-for-test-case}
    {self.results.clear}
  }
  
  {method public {run-all-test-cases}:void
    {for test-case in self.test-cases do
        {self.reset-for-test-case}
        {self.run-test-case test-case}
    }    
  }
  
  {method public {run-test-case test-case:String}:void
    {if not {self.sha-test-files.key-exists? test-case} then
        {self.results.add
            {bold color = "red", Unknown test case {value test-case}}
        }
        {return}
    }
    
    let tf:Url = self.sha-test-files[test-case]
    
    || digester?
    set self.current-digester =
        {if {test-case.find-string "512"} >= 0 then
            512
         elseif {test-case.find-string "384"} >= 0 then
            384
         elseif {test-case.find-string "256"} >= 0 then
            256
         elseif {test-case.find-string "224"} >= 0 then
            224
         else
            1
        }
    
    {self.parse-file tf}
    {self.display-header}
    
    {self.run-tests}
    {self.display-finished-message}
  }
  
  {method {display-header}:void
    {for s in self.header do
        {self.results.add s}
    }  
    {dispatch-events false}
  }
  {method {display-finished-message}:void
    let prate:Percent = self.pass-count / self.test-count
    
    {self.results.add
        {VBox
            color =
                {if prate != 1.0 then "red"
                 else "black"
                },
            {bold Completed test case {value self.current-test-case}. pass rate = {value self.pass-count} / {value self.test-count}},
            {hrule}
        }
    }
    {dispatch-events false}
  }
}



{value

    let tv:HMAC-TestVector = {HMAC-TestVector}
    {VBox height = 10cm, width = 20cm,
        {bold COM.CURLR.CRYPTO tests for HMAC implementations.},
        {paragraph This utility runs the pre-validation tests for the NIST {link href={url "http://csrc.nist.gov/cryptval/mac/HMACVS.pdf"},
            HMAC Validation System.}
        },
        {paragraph Passing these tests does NOT constitute validation of the implementation.},
            
        
        {HBox valign = "top",
            {CommandButton label = "reset ...",
                {on Action do
                    {tv.reset-all}
                }
            },
            tv.run-test-cb,
            tv.test-selector,
            {CheckButton label = "show fail only?",
                value = true,
                {on ValueChanged at cb:CheckButton do
                    set tv.show-fail-only? = cb.value
                }
            },
            tv.pass-count-td,
            {bold / },
            tv.test-count-td

        },
        {ScrollBox
            tv.results
        }
    } 
}